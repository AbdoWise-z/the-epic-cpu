Library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
-- memory is big endian (address 1: 31- 16 2:15 - 0)
Entity Instruction_Memory is 
port( 
	WriteEnable,Protect,Free,Reset: in std_logic;
	datain,Address:  in std_logic_vector(31 downto 0);
	OutValue:	out std_logic_vector(31 downto 0);
	error	:       out std_logic
	
);
end Entity Instruction_Memory;


Architecture Instruction_Memoryarch of Instruction_Memory is
Type ram_type is Array(0 to 4095) of std_logic_vector(15 downto 0);
-- Array type of 4096 word addressable == 8192 byte addressable
	Signal ram: ram_type;
	Signal Protect_Bit: std_logic_vector(4095 downto 0); 
begin
process
begin
--todo: how to read and write
	if((to_integer(unsigned(Address(11 downto 0))) mod 2) = 1) then
		if(rising_edge(WriteEnable)) then
			if(Protect_Bit(to_integer(unsigned(Address(11 downto 0)))) = '1') then
				error<='1';
			else
			ram(to_integer(unsigned(Address(11 downto 0)))) <= datain(31 downto 16);
			ram(to_integer(unsigned(Address(11 downto 0))+1)) <=datain(15 downto 0);
			end if;
		elsif(rising_edge(Protect)) then
			Protect_Bit(to_integer(unsigned(Address(11 downto 0))))<= '1';
		elsif(rising_edge(Free)) then
			Protect_Bit(to_integer(unsigned(Address(11 downto 0))))<= '0';
		end if;

		OutValue <= ram(to_integer(unsigned(Address(11 downto 0))))&ram(to_integer(unsigned(Address(11 downto 0))+1));
	else 
		error <='1';
	end if;
	

end process;

end Architecture Instruction_Memoryarch;
